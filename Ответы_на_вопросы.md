
# 	Вопросы по третьей лабе

##	Инъекции бинов

### Внедрение зависимостей
Основой, на которой сейчас построены самые популярные фрэймворки, является внедрение зависимостей. 

Существует спецификация **CDI** - Contexts and Dependency Injection ([JCP 365](https://jcp.org/en/jsr/detail?id=365))

У бинов в контексте CDI есть свой скоуп в течении которого они существуют. Скоуп задается с помощью аннотаций из пакета javax.enterprise.context:

    @RequestScoped
    @SessionScoped
    @ApplicationScoped
    @ViewScoped
    @FlowScoped
    @Dependent
    @ConversationScoped

* `@RequestScoped` - bean живет до тех пор, пока один цикл HTTP-запроса-ответа 
(обратите внимание, что запрос Ajax считается один HTTP-запрос тоже).

> Используйте `@RequestScoped` для простых и не-ajax форм

* `@ViewScoped` bean живет до тех пор, пока вы взаимодействуете с одним и тем же представлением JSF 
 с помощью обратных связей, которые вызывают методы действия, возвращающие null/void без какой-либо навигации/перенаправления.
 
 > Используйте `@ViewScoped` для расширенных динамических представлений
  с поддержкой ajax (ajaxbased validation, rendering, dialogs и т. д.).
 
* `@FlowScoped ` bean живет до тех пор, пока вы перемещаетесь по указанной коллекции представлений, 
 зарегистрированных в файле конфигурации потока.
 
> Используйте `@FlowScoped` для шаблона" мастер "("анкета") сбора входных данных распространение на нескольких страницах.

* `@SessionScoped`  bean живет до тех пор, пока установлен сеанс HTTP.

> Используйте `@SessionScoped` для конкретных данных клиента, таких как вошедший в систему пользователь и пользовательские настройки (язык и т. д.)

* `@ApplicationScoped` bean живет в пока работает веб-приложение

> Используйте `@ApplicationScoped` для общих данных/констант приложения,
таких как выпадающие списки, которые одинаковы для всех,
или управляемые компоненты без каких-либо переменных экземпляра и имеющие только методы.

* Используемый по умолчанию в CDI, `Dependent` привязывается непосредственно к бину клиента
 и существует все время пока живет “родитель”.

* `@ConversationScoped` представляет собой определенный промежуток времени взаимодействия
 пользователя с конкретной вкладкой в браузере. Поэтому он чем-то похож на жизненный цикл сессии,
  но важное отличие в том, что старт “сессии” задается вручную. 
  Для этого объявлен интерфейс *javax.enterprise.context.Conversation*, который определяет методы `start()`, `end()`, 
   a также `setTimeout(long)`, для закрытия сессии по истечении времени.
   
### Ошибки при черезмерном использовании различных скопов

* Злоупотребляя `@ApplicationScoped` bean для данных с областью сеанса/просмотра/запроса 
сделал бы его общим для всех пользователей, поэтому любой другой может видеть данные друг друга, 
что просто неправильно. 

* Злоупотребление `@SessionScoped` bean for view / request scoped data 
сделает его общим для всех вкладок / окон в одном сеансе браузера, 
поэтому конечный пользователь может испытывать несоответствия при взаимодействии 
с каждым представлением после переключения между вкладками, что плохо сказывается на работе пользователя. 

* Злоупотребление `@RequestScoped` bean для данных с областью видимости сделает данные с областью видимости повторно
 инициализированными по умолчанию для каждой обратной передачи (ajax), 
 что может привести к нерабочим формам (см. также пункты 4 и 5 здесь). 
 
* Злоупотребление `@ViewScoped`  для запроса, сессии или приложения уровня данных, 
 а также злоупотребление `@SessionScoped` bean для данных области применения не влияет на клиента, 
 но он излишне занимает память сервера и просто неэффективен.
 
### Доступ бинов друг к другу

Бобы могут просто получить доступ друг к другу через `@ManagedProperty` в случае JSF управляемых бобов 
или `@Inject` в случае управляемых CDI бобов

Эта фигня по сути просто экземпляр создаёт для того, что тебе надобно
```java
    @Inject
    Foo myFoo;
```
это что-то в духе
```java
    myFoo = new Foo();
```

### CustomScoped/ NoneScoped/ Dependent

 JSF также поддерживает `@CustomScoped` и `@NoneScoped`, которые редко используются в реальном мире. 
 Элемент `@CustomScoped ` должен ссылаться на пользовательский Map<K, Bean> реализация в какой-то более широкой области, 
 которая переопределила `Map#put()` и/или `Map#get()` чтобы иметь более мелкозернистый контроль 
 над созданием и/или уничтожением бобов. 
 
 None ( @NoneScoped ): указывает, что область не определена для приложения
 `@NoneScoped` - инстанс создаётся, но не привязывается ни к одной области жизни.
  Полезно применять в managed bean'е, на который ссылаются другие managed bean'ы, имеющие область жизни

## Что-то про JSF и пользователя
### Запросы там то сё
В JSF встречаются два вида запросов от клиента:

- **Первый запрос (initial request)** - пользователь запрашивает страницу в первый раз
- **Postback** - отправка формы со страницы, которая была показана при первом запросе

JSF представляет собой набор пользовательских компонентов в виде дерева, которые формируют представление.
 Представление представлено объектом **UIViewRoot**, который связан с активным FacesContext.
 
  Состояние представления может сохраняться как на клиентской стороне (в hidden полях), 
  так и на серверной (по умолчанию). 
  
  Во время выполнения, JSF реализация создаёт представление при первом обращении (запросе), 
  либо восстанавливает уже созданное. Когда клиент отправляет форму (postback), 
  JSF конвертирует отправленные данные, проверяет их, сохраняет в managed bean, находит представление для навигации, 
  восстанавливает значения компонента из managed bean, генерирует ответ по представлению. 
  
  Все эти действия JSF описывает с помощью 6 упорядоченных процессов, 
  которыми можно управлять (вызывая например метод `renderResponse()` у активного FacesContext, либо используя свойство компонентов `immediate="true"`). Каждый раз, как пользователь отправляет запрос на сервер, один либо более процессов принимают участие в его обработке, после чего формируется и отправляется ответ
  
### Фазы жизненного цикла JSF
Фазы жизненного цикла JSF запроса - ответа можно представить следующим образом:

    1 Восстановление представления
    2 Получение (конвертирование) значений запроса и обработка событий
    3 Проверка значений и обработка событий
    4 Обновление свойств managed bean и обработка событий
    5 Обработка приложения и событий
    6 Формирование ответа


**Восстановление представления** 
- в этой фазе JSF пытается найти представление, которое соответствует запрошенной странице. 
Если представление не существует, то будет создано новое представление. 
Значения, обработчики событий, валидаторы и конверторы загружаются с компонентами, которым они принадлежат.
Инициализируются языковые настройки. 
Если в этой фазе выполняется первый запрос (initial request), то представление не имеет состояния, 
и JSF пропускает все остальные шаги обработки этого запроса до фазы Формирование ответа. 
Если же в этой фазе выполняется postback, тогда JSF изменяет созданное состояние представления, 
и отправляет запрос на фазу Получение (конвертирование) значений запроса и обработка событий

**Получение (конвертирование) значений запроса и обработка событий** 
- в этой фазе JSF расшифровывает HTTP запрос, 
получает HTTP параметры и передаёт их компонентам в дереве компонентов. 
Представление рекурсивно проходится по дереву компонентов, и вызывает у каждого компонента метод decode(). 
Каждый компонент определяет свой параметр в HTTP запросе (по id), 
и заменяет существующее значение на новое (setSubmittedValue()). 
При этом, если к компоненту привязан конвертер, то значение конвертируется. 
Если в процессе конвертации произошли ошибки, то ошибка сохраняется и JSF пропускает все остальные шаги 
обработки этого запроса до фазы Формирование ответа для предупреждения пользователя об ошибке. 
Если компонент ввода (UIInput) содержит валидатор и имеет свойство immediate="true", 
то этот компонент будет валидироваться в этой фазе.

**Проверка значений и обработка событий** 
- в этой фазе JSF валидирует дерево компонентов, 
вызывая у каждого компонента метод validate(). 
Если валидация компонента прошла с ошибкой, то ошибка сохраняется и JSF пропускает все остальные 
шаги обработки этого запроса до фазы Формирование ответа для предупреждения пользователя об ошибке.

**Обновление свойств managed bean и обработка событий** 
- в этой фазе JSF обновляет managed bean информацией из дерева 
компонентов.

**Обработка приложения и событий**
- в этой фазе JSF обрабатывает события, которые пришли от кнопок и ссылок. Если один из этих компонентов имеет свойство immediate="true", то он должен был быть уже обработан в фазе Получение (конвертирование) значений запроса и обработка событий. На данном этапе также происходит вычисление навигации для приложения, если навигация необходима.
Формирование ответа - в этой фазе JSF просит web-контейнер создать ответ, основываясь на данных, полученных из предыдущих шагов. Компоненты на странице обновляются данными из managed bean и генерируют html страницу с помощью Renderers. Если на предыдущих шагах происходили какие-либо ошибки, то они инкапсулируются в тег <messages>. Для выполнения этих действий JSF спецификация требует наличия обработчика представления (view handler).


![JSF lifecircle ](http://java-online.ru/images/web/lifecycle.png)


[Injecting Managed beans in JSF 2.0](https://www.mkyong.com/jsf2/injecting-managed-beans-in-jsf-2-0/)

[JSF bean injection - как передать значение](https://qarchive.ru/8872069_jsf_bean_injection___kak_peredat__znachenie)


[Custom scope - 1](https://cribsee.blogspot.com/2014/03/custom-scope-jsf-2.html)

[Custom scope - 2](https://blog.oio.de/2012/07/24/jsf-2-custom-scopes-without-3rd-party-libraries/)

## Комментарии в JSF

Небольшая заметка по поводу комментариев в JSF. Я думаю многие сталкивались с ситуацией, когда в комментарии попадают jsf-теги. Проблема заключается в том, что некоторые выражения, находящиеся в закомментированных тегах, все равно вычисляются. Данное поведение может привести к непредсказуемым сторонним эффектам, а также быть причиной возникновения эксепшенов.

 Чтобы этого избежать, необходимо добавить в web.xml следующие строки:
```xml
<context-param>
    <param-name>facelets.SKIP_COMMENTS</param-name>
    <param-value>true</param-value>
</context-param>
```

Теперь jsf-теги в комментариях не будет учитываться и все должно обрабатываться нормально.

##	ORM-провайдеры

 **ORM** - «Object-relational mapping», что значит «Объектно-реляционное отображение».
 
 То есть сущности БД представляются в виде объектов
 
 ![ORM scheme](https://javarush.ru/pictures/1293665/ca5cabab-71fd-4ab3-bd30-aca3d18f02a4.png)
 
 Персистентность в Java. Персистентость это сохраняемость данных.
 
 **JPA (Java Persistence API)** это спецификация Java EE и Java SE, описывающая систему управления сохранением java 
 объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако есть существует 
 много реализаций данной спецификации от разных компаний (открытых и нет). 
 Это не единственный способ сохранения java объектов в базы данных (ORM систем), 
 но один из самых популярных в Java мире.
 
 Сущности в мире JPA живут в некотором пространстве, которое называется "Контекст персистенции" 
 (или Контексте постоянства, Persistence Context). Но напрямую мы не работаем с Persistence Context. 
 Для этого мы используем Entity Manager или "менеджер сущностей". Именно он знает про контекст и про то, 
 какие там живут сущности. Мы же взаимодействуем с Entity Manager'ом.
 
 Самая распространённая реализация спецификации - **Hibernate**
 
 Библиотека не только решает задачу связи классов Java с таблицами базы данных (и типов данных Java с типами данных SQL),
 но и также предоставляет средства для автоматической генерации и обновления набора таблиц, 
 построения запросов и обработки полученных данных и может значительно уменьшить время разработки, 
 которое обычно тратится на ручное написание SQL- и JDBC-кода. Hibernate автоматизирует 
 генерацию SQL-запросов и освобождает разработчика от ручной обработки результирующего набора данных и 
 преобразования объектов, максимально облегчая перенос (портирование) приложения на любые базы данных SQL. 
 
 Классы сущностей должны соответсвовать определенным требованиям:
  - наличие конструктора по умолчанию
  - геттеры и сеттеры   
  
  Затем надо замапить всё в xml файле
  
  Пример
  
  Теперь для наших классов необходимо описать маппинг в виде xml-файлов, эти файлы как раз и будут отвечать за взаимодействие наших объектов с Hibernate и с базой данных.
  Bus.hbm.xml
  
  ```xml
      <hibernate-mapping>
        <class name=«logic.Bus» table=«busses»>
          <id column=«bus_id» name=«id» type=«java.lang.Long»>
            <generator class=«increment»/>
          </id>
          <property column=«number» name=«number» type=«java.lang.String»/>
          
          <set name=«drivers» table=«busDriver» lazy=«false»>
            <key column=«bus_id»/>
            <many-to-many column=«driver_id» class=«logic.Driver»/>
          </set>
        </class>
      </hibernate-mapping>
 ```

Теперь давайте немного разберемся в этих xml-ных макаронах :)
- Тег `hibernate-mapping` я думаю понятен, тут ничего говорить не стоит.
-  Тег `class` имеет два параметра: параметр name — Имя класса (необходимо указывать полный путь с учетом структуры пакетов) и параметр table — имя таблицы в базе данных, на которую будет маппиться наш класс.
 -   Тег `id` описывает идентификатор. Параметр column указывает на какую колонку в таблице будет ссылаться поле id нашего объекта, так же указываем класс и указываем generator, который отвечает за генерацию id.
-    Тег `property` описывает простое поле нашего объекта, в качестве параметров указываем имя поля, его класс и имя колонки в таблице.
 -   Тег `set` описывает поле в котором содержится некий набор(коллекция) объектов. Тег содержит параметр name — имя поля нашего объекта, параметр table — имя таблицы связи(в случае отношения многие ко многим) и параметр lazy. Lazy, если меня не подводит моя память, с английского — ленивый. Так называемые ленивые коллекци, сейчас постараюсь объяснить понятнее. Когда мы в параметре lazy указываем значечение false, то у нас при получении объекта Route из базы вместе с объектом достается и коллекция объектов Bus, так как busses это поле объекта Route. А если в качестве параметра мы указываем значение true, то коллекция объектов Bus не вытаскивается, для ее получения надо явно вызывать метод route.getBusses(). Вот предположим такой очень хороший пример. Есть объект город, в него входит массив районов, в каждый район — массив улиц, в каждую улицу — массив домов и так далее до людей, живущих в квартирах. Предположим мы хотим вытянуть из базы названия районов. Если укажем lazy = false, то помимо районом у нас вытянется еще огромный объем «ненужных» данных, если же lazy = true, то мы получим то что надо и ничего лигнего.
  -  Тег `key` имеет параметр column, который говорит, на какую колонку в таблице связи будет ссылаться поле нашего объекта.
  -  Тег `many-to-many` описывает связь типа многие ко многим, в качестве параметров тег использует column — имя колонки второй колонки в таблице связи и параметр class, указывающий какого класса будут объеты на той стороне.


[ORM или как забыть о проектировании БД](https://habr.com/en/post/237889/)

[Вики](https://ru.wikipedia.org/wiki/ORM)

##	Технология JavaServer Faces.

http://java-online.ru/jsf.xhtml

http://javastudy.ru/interview/jee-jsf-questions-answers/

http://javastudy.ru/interview/jee-jsf-questions-answers-2/

###	Особенности, отличия от сервлетов и JSP, преимущества и недостатки.

http://qaru.site/questions/2705/what-is-the-difference-between-jsf-servlet-and-jsp

https://www.codeissue.com/issues/i850251909a4114/difference-between-jsf-vs-jsp-vs-servlet

###	Структура JSF-приложения.

![image-20191031145245036](C:\Users\fools\AppData\Roaming\Typora\typora-user-images\image-20191031145245036.png)

##	Использование JSP-страниц и Facelets-шаблонов в JSF-приложениях.

​	

##	JSF-компоненты - особенности реализации, иерархия классов.

![image-20191031145603618](C:\Users\fools\AppData\Roaming\Typora\typora-user-images\image-20191031145603618.png)

https://aneiprog.blogspot.com/2013/03/composite-components-jsf2.html

###	Дополнительные библиотеки компонентов.

https://www.ibm.com/developerworks/ru/library/r-0926_kats/index.html

###	Модель обработки событий в  JSF-приложениях.

![image-20191031181659876](C:\Users\fools\AppData\Roaming\Typora\typora-user-images\image-20191031181659876.png)

##	Конвертеры и валидаторы данных.

http://java-online.ru/jsf-validation.xhtml

##	Представление страницы JSF на стороне сервера. Класс UIViewRoot.

Презентация страницы 212 - 217.

##	Управляемые бины - назначение, способы конфигурации.

https://www.tutorialspoint.com/jsf/jsf_managed_beans.htm

https://proselyte.net/tutorials/jsf-tutorial/jsf-managed-beans/

###	Контекст управляемых бинов.

##	Конфигурация JSF-приложений. Файл faces-config.xml. Класс FacesServlet.

https://docs.oracle.com/cd/B31017_01/web.1013/b25947/appendixa009.htm

https://docs.oracle.com/javaee/7/api/javax/faces/webapp/FacesServlet.html

##	Навигация в JSF-приложениях.

http://java-online.ru/jsf-navigation.xhtml

http://javawebtutor.com/articles/jsf/jsf_page_navigation.php
